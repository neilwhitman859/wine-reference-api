from pathlib import Path
from typing import Any, Optional
from datetime import datetime, timezone
import json
import os
import re
import subprocess
from urllib import parse, request

from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse
from openai import OpenAI

app = FastAPI()
BASE_DIR = Path(__file__).resolve().parent
CMS_DIR = BASE_DIR.parent / "cms"
CMS_WINES_DIR = CMS_DIR / "wines"
XWINES_CLONE_DIR = CMS_DIR / "sources" / "x-wines"


@app.get("/")
def home():
    return FileResponse(BASE_DIR / "static" / "index.html")


@app.get("/health")
def health():
    return {
        "status": "ok",
        "version": "2026-02-18 002",
        "last_updated": datetime.now(timezone.utc).isoformat(),
    }


@app.get("/sources/health")
def sources_health():
    CMS_WINES_DIR.mkdir(parents=True, exist_ok=True)
    wine_count = len(list(CMS_WINES_DIR.glob("*.json")))
    winevybe_url = os.getenv("WINEVYBE_API_URL")
    vinou_url = os.getenv("VINOU_API_URL")
    openai_key = os.getenv("OPENAI_API_KEY")
    return {
        "checked_at": datetime.now(timezone.utc).isoformat(),
        "sources": {
            "git_cms": {
                "configured": True,
                "wine_count": wine_count,
            },
            "winevybe": {
                "configured": bool(winevybe_url),
                "url": winevybe_url,
            },
            "vinou": {
                "configured": bool(vinou_url),
                "url": vinou_url,
            },
            "openai": {
                "configured": bool(openai_key),
            },
        },
    }


def _extract_json_payload(text: str) -> dict[str, Any]:
    cleaned = text.strip()
    if cleaned.startswith("```"):
        lines = cleaned.splitlines()
        if lines:
            lines = lines[1:]
        if lines and lines[-1].strip().startswith("```"):
            lines = lines[:-1]
        cleaned = "\n".join(lines).strip()

    try:
        parsed = json.loads(cleaned)
    except json.JSONDecodeError as exc:
        raise HTTPException(
            status_code=500,
            detail=(
                "OpenAI returned non-JSON output. "
                "Try again with a more specific wine name and vintage."
            ),
        ) from exc

    if not isinstance(parsed, dict):
        raise HTTPException(status_code=500, detail="OpenAI returned invalid JSON payload.")

    return parsed


@app.get("/explain-wine")
def explain_wine(name: str, vintage: Optional[int] = None):
    parsed_name, parsed_vintage = _normalize_wine_query(name=name, vintage=vintage)
    cms_payload = _fetch_git_cms_wine_data(parsed_name, parsed_vintage)
    winevybe_payload = _fetch_winevybe_wine_data(parsed_name, parsed_vintage)
    vinou_payload = _fetch_vinou_wine_data(parsed_name, parsed_vintage)

    if cms_payload:
        source = "git_cms"
        structured = _normalize_git_cms_payload(cms_payload)
    elif winevybe_payload:
        source = "winevybe"
        structured = _normalize_winevybe_payload(winevybe_payload)
    elif vinou_payload:
        source = "vinou"
        structured = _normalize_vinou_payload(vinou_payload)
    else:
        source = "openai"
        structured = _fetch_openai_payload(parsed_name, parsed_vintage)

    growing_season_weather = _build_growing_season_weather(
        climate_context=structured.get("climate_context", {}),
        selected_vintage=parsed_vintage,
    )

    return {
        "wine": parsed_name,
        "vintage": parsed_vintage,
        "summary": structured.get("summary"),
        "description_breakdown": structured.get("description_breakdown", {}),
        "vintage_intelligence": structured.get("vintage_intelligence", {}),
        "growing_season_weather": growing_season_weather,
        "uncertainty_notes": structured.get("uncertainty_notes", []),
        "data_source": source,
        "data_source_note": (
            "Core wine details were sourced from the local Git-based CMS."
            if source == "git_cms"
            else
            "Core wine details were sourced from WineVybe API."
            if source == "winevybe"
            else
            "Core wine details were sourced from Vinou API."
            if source == "vinou"
            else "Vinou data was unavailable; details were generated by OpenAI."
        ),
        "source_highlights": _build_source_highlights(
            winevybe_payload=winevybe_payload,
            vinou_payload=vinou_payload,
            cms_payload=cms_payload,
            source=source,
            structured=structured,
        ),
        "raw_openai_payload": structured,
    }


@app.get("/cms/wines")
def list_cms_wines():
    CMS_WINES_DIR.mkdir(parents=True, exist_ok=True)
    wines: list[dict[str, Any]] = []
    for item in sorted(CMS_WINES_DIR.glob("*.json")):
        payload = _load_json_file(item)
        if payload:
            wines.append(payload)
    return {"count": len(wines), "wines": wines}


@app.get("/cms/wines/{slug}")
def get_cms_wine(slug: str):
    payload = _load_json_file(_cms_wine_path(slug))
    if not payload:
        raise HTTPException(status_code=404, detail="Wine entry not found in CMS.")
    return payload


@app.put("/cms/wines/{slug}")
def upsert_cms_wine(slug: str, payload: dict[str, Any]):
    normalized = _normalize_cms_document(payload)
    normalized["slug"] = slug
    _write_cms_wine(slug, normalized)
    return {"status": "saved", "slug": slug, "wine": normalized}


@app.post("/cms/import/x-wines")
def import_x_wines(limit: int = 500):
    repo_url = "https://github.com/rogerioxavier/X-Wines.git"
    imported = _import_x_wines_dataset(repo_url=repo_url, limit=limit)
    return {
        "status": "ok",
        "source": repo_url,
        "imported": imported,
    }


def _normalize_git_cms_payload(payload: Optional[dict[str, Any]]) -> dict[str, Any]:
    if not payload:
        return {}

    tasting = payload.get("tasting_profile") or {}
    drinking = payload.get("drinking_experience") or {}
    return {
        "wine_name": payload.get("wine_name") or payload.get("name"),
        "requested_vintage": payload.get("vintage"),
        "summary": payload.get("summary") or "Git CMS entry with no summary.",
        "description_breakdown": {
            "producer_and_region": f"{payload.get('producer') or 'Not disclosed'}, {payload.get('region') or 'Not disclosed'}",
            "grape_composition_and_style": payload.get("grape_composition") or payload.get("grapes") or "Not disclosed",
            "tasting_profile": {
                "aroma": tasting.get("aroma") or payload.get("aroma_notes") or [],
                "palate": tasting.get("palate") or payload.get("palate_notes") or [],
                "finish": tasting.get("finish") or payload.get("finish") or "Not specified",
            },
            "drinking_experience": {
                "body": drinking.get("body") or payload.get("body") or "Not specified",
                "acidity": drinking.get("acidity") or payload.get("acidity") or "Not specified",
                "tannin": drinking.get("tannin") or payload.get("tannin") or "Not specified",
                "alcohol_impression": drinking.get("alcohol_impression") or "Not specified",
                "serving_guidance": drinking.get("serving_guidance") or payload.get("serving") or "Not specified",
                "food_pairings": drinking.get("food_pairings") or payload.get("food_pairings") or [],
                "cellaring_window": drinking.get("cellaring_window") or payload.get("cellaring") or "Not specified",
            },
        },
        "vintage_intelligence": payload.get("vintage_intelligence") or {},
        "climate_context": payload.get("climate_context") or {},
        "uncertainty_notes": payload.get("uncertainty_notes") or [],
        "wine_type": payload.get("wine_type"),
        "abv": payload.get("abv"),
        "availability_status": payload.get("availability_status"),
        "comparable_wines": payload.get("comparable_wines"),
    }


def _fetch_openai_payload(parsed_name: str, parsed_vintage: Optional[int]) -> dict[str, Any]:
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise HTTPException(
            status_code=500,
            detail="OPENAI_API_KEY is not set in the server environment.",
        )

    client = OpenAI(api_key=api_key)

    vintage_context = f"Selected vintage: {parsed_vintage}" if parsed_vintage else "No specific vintage selected"

    prompt = f"""You are a professional sommelier and wine market analyst.

Provide a detailed JSON response for this wine:
- Bottle: {parsed_name}
- {vintage_context}

Requirements:
1) Respond ONLY as valid JSON. No markdown, no prose outside JSON.
2) Keep every field concise, data-driven, and professional in tone.
3) Prioritize measurable statements (temperature/rainfall deviations, timing, relative ranking) over generic adjectives.
4) If certainty is low, include assumptions in the `uncertainty_notes` field.
5) Include weather-pattern-driven vintage insight based on broadly documented regional climate patterns and harvest timing.

Use this exact JSON shape:
{{
  "wine_name": "string",
  "requested_vintage": "number or null",
  "summary": "2-4 sentence approachable summary",
  "description_breakdown": {{
    "producer_and_region": "string",
    "grape_composition_and_style": "string",
    "tasting_profile": {{
      "aroma": ["string"],
      "palate": ["string"],
      "finish": "string"
    }},
    "drinking_experience": {{
      "body": "string",
      "acidity": "string",
      "tannin": "string",
      "alcohol_impression": "string",
      "serving_guidance": "string",
      "food_pairings": ["string"],
      "cellaring_window": "string"
    }}
  }},
  "vintage_intelligence": {{
    "selected_vintage_assessment": "string",
    "comparison_to_adjacent_vintages": "string",
    "weather_patterns": [
      {{
        "period": "string",
        "pattern": "string",
        "impact_on_grapes": "string",
        "quality_signal": "string"
      }}
    ],
    "buying_guidance": "string"
  }},
  "climate_context": {{
    "region": "string",
    "latitude": "number",
    "longitude": "number",
    "growing_season": {{
      "start_month": "number",
      "start_day": "number",
      "end_month": "number",
      "end_day": "number"
    }}
  }},
  "uncertainty_notes": ["string"]
}}
"""

    try:
        resp = client.responses.create(
            model="gpt-4.1-mini",
            input=prompt,
        )
        raw_output = resp.output_text
        if not raw_output:
            raise HTTPException(
                status_code=500,
                detail="OpenAI returned an empty response.",
            )
        return _extract_json_payload(raw_output)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"OpenAI call failed: {repr(e)}")


def _cms_wine_path(slug: str) -> Path:
    return CMS_WINES_DIR / f"{slug}.json"


def _slugify(value: str) -> str:
    lowered = re.sub(r"[^a-z0-9]+", "-", value.lower()).strip("-")
    return lowered or "wine"


def _load_json_file(path: Path) -> Optional[dict[str, Any]]:
    if not path.exists():
        return None
    try:
        with path.open("r", encoding="utf-8") as handle:
            payload = json.load(handle)
    except Exception:
        return None
    return payload if isinstance(payload, dict) else None


def _write_cms_wine(slug: str, payload: dict[str, Any]) -> None:
    CMS_WINES_DIR.mkdir(parents=True, exist_ok=True)
    with _cms_wine_path(slug).open("w", encoding="utf-8") as handle:
        json.dump(payload, handle, ensure_ascii=False, indent=2)


def _normalize_cms_document(payload: dict[str, Any]) -> dict[str, Any]:
    now = datetime.now(timezone.utc).isoformat()
    normalized = dict(payload)
    normalized.setdefault("name", payload.get("wine_name") or "Unknown wine")
    normalized.setdefault("wine_name", normalized["name"])
    normalized.setdefault("summary", "No summary yet.")
    normalized["updated_at"] = now
    normalized.setdefault("created_at", now)
    return normalized


def _fetch_git_cms_wine_data(name: str, vintage: Optional[int]) -> Optional[dict[str, Any]]:
    CMS_WINES_DIR.mkdir(parents=True, exist_ok=True)
    requested_slug = _slugify(name)
    payload = _load_json_file(_cms_wine_path(requested_slug))
    if payload and _matches_vintage(payload, vintage):
        return payload

    for item in CMS_WINES_DIR.glob("*.json"):
        candidate = _load_json_file(item)
        if not candidate:
            continue
        candidate_name = str(candidate.get("name") or candidate.get("wine_name") or "").strip().lower()
        if candidate_name == name.strip().lower() and _matches_vintage(candidate, vintage):
            return candidate
    return None


def _matches_vintage(payload: dict[str, Any], requested: Optional[int]) -> bool:
    if requested is None:
        return True
    try:
        return int(payload.get("vintage")) == requested
    except (TypeError, ValueError):
        return False


def _import_x_wines_dataset(repo_url: str, limit: int) -> int:
    CMS_WINES_DIR.mkdir(parents=True, exist_ok=True)
    XWINES_CLONE_DIR.parent.mkdir(parents=True, exist_ok=True)
    if XWINES_CLONE_DIR.exists():
        subprocess.run(["git", "-C", str(XWINES_CLONE_DIR), "pull", "--ff-only"], check=False)
    else:
        subprocess.run(["git", "clone", "--depth", "1", repo_url, str(XWINES_CLONE_DIR)], check=False)

    dataset_file = _find_x_wines_dataset_file(XWINES_CLONE_DIR)
    if not dataset_file:
        raise HTTPException(status_code=502, detail="X-Wines repository cloned but no supported dataset file was found.")

    records = _load_x_wines_records(dataset_file)
    imported = 0
    for record in records:
        if imported >= max(1, limit):
            break
        mapped = _map_x_wines_record(record)
        if not mapped:
            continue
        slug = _slugify(f"{mapped.get('name', 'wine')}-{mapped.get('vintage') or 'nv'}")
        existing = _load_json_file(_cms_wine_path(slug)) or {}
        merged = _normalize_cms_document({**existing, **mapped, "source": "x-wines"})
        merged["slug"] = slug
        _write_cms_wine(slug, merged)
        imported += 1
    return imported


def _find_x_wines_dataset_file(repo_dir: Path) -> Optional[Path]:
    candidates = [
        *repo_dir.glob("*.json"),
        *repo_dir.glob("*.csv"),
        *repo_dir.glob("data/*.json"),
        *repo_dir.glob("data/*.csv"),
        *repo_dir.glob("dataset/*.json"),
        *repo_dir.glob("dataset/*.csv"),
    ]
    for file in candidates:
        if "wine" in file.name.lower():
            return file
    return candidates[0] if candidates else None


def _load_x_wines_records(dataset_file: Path) -> list[dict[str, Any]]:
    suffix = dataset_file.suffix.lower()
    if suffix == ".json":
        with dataset_file.open("r", encoding="utf-8") as handle:
            payload = json.load(handle)
        if isinstance(payload, list):
            return [item for item in payload if isinstance(item, dict)]
        if isinstance(payload, dict):
            if isinstance(payload.get("data"), list):
                return [item for item in payload["data"] if isinstance(item, dict)]
            return [payload]
        return []

    if suffix == ".csv":
        lines = dataset_file.read_text(encoding="utf-8").splitlines()
        if not lines:
            return []
        headers = [part.strip() for part in lines[0].split(",")]
        rows: list[dict[str, Any]] = []
        for line in lines[1:]:
            values = [part.strip() for part in line.split(",")]
            if len(values) != len(headers):
                continue
            rows.append({headers[idx]: values[idx] for idx in range(len(headers))})
        return rows

    return []


def _map_x_wines_record(record: dict[str, Any]) -> Optional[dict[str, Any]]:
    name = record.get("name") or record.get("wine") or record.get("wine_name")
    if not name:
        return None
    return {
        "name": str(name),
        "wine_name": str(name),
        "vintage": _safe_int(record.get("vintage"), 0) or None,
        "producer": record.get("winery") or record.get("producer"),
        "region": record.get("region") or record.get("country"),
        "summary": record.get("description") or record.get("summary") or "Imported from X-Wines dataset.",
        "grape_composition": record.get("grapes") or record.get("variety"),
        "wine_type": record.get("type") or record.get("wine_type"),
        "abv": record.get("abv") or record.get("alcohol"),
    }


def _fetch_vinou_wine_data(name: str, vintage: Optional[int]) -> Optional[dict[str, Any]]:
    vinou_url = os.getenv("VINOU_API_URL")
    if not vinou_url:
        return None

    params = {"name": name}
    if vintage is not None:
        params["vintage"] = vintage

    req = request.Request(f"{vinou_url}?{parse.urlencode(params)}")
    req.add_header("Accept", "application/json")
    vinou_api_key = os.getenv("VINOU_API_KEY")
    if vinou_api_key:
        req.add_header("Authorization", f"Bearer {vinou_api_key}")

    try:
        with request.urlopen(req, timeout=12) as response:
            payload = json.loads(response.read().decode("utf-8"))
    except Exception:
        return None

    if not isinstance(payload, dict):
        return None

    data = payload.get("data") if isinstance(payload.get("data"), dict) else payload
    return data if isinstance(data, dict) and data else None


def _fetch_winevybe_wine_data(name: str, vintage: Optional[int]) -> Optional[dict[str, Any]]:
    winevybe_url = os.getenv("WINEVYBE_API_URL")
    if not winevybe_url:
        return None

    params = {"name": name}
    if vintage is not None:
        params["vintage"] = vintage

    req = request.Request(f"{winevybe_url}?{parse.urlencode(params)}")
    req.add_header("Accept", "application/json")
    winevybe_api_key = os.getenv("WINEVYBE_API_KEY")
    if winevybe_api_key:
        req.add_header("Authorization", f"Bearer {winevybe_api_key}")

    try:
        with request.urlopen(req, timeout=12) as response:
            payload = json.loads(response.read().decode("utf-8"))
    except Exception:
        return None

    if not isinstance(payload, dict):
        return None

    data = payload.get("data") if isinstance(payload.get("data"), dict) else payload
    return data if isinstance(data, dict) and data else None


def _normalize_winevybe_payload(winevybe_payload: Optional[dict[str, Any]]) -> dict[str, Any]:
    if not winevybe_payload:
        return {}

    tasting = winevybe_payload.get("tasting") or winevybe_payload.get("tasting_profile") or {}
    experience = winevybe_payload.get("drinking") or winevybe_payload.get("drinking_experience") or {}
    climate_context = winevybe_payload.get("climate_context") or winevybe_payload.get("climate") or {}

    grapes = winevybe_payload.get("grapes") or winevybe_payload.get("grape_composition")
    if isinstance(grapes, list):
        grape_text = ", ".join(str(item) for item in grapes)
    else:
        grape_text = str(grapes or winevybe_payload.get("blend") or "Not disclosed")

    producer = winevybe_payload.get("producer") or winevybe_payload.get("winery") or "Not disclosed"
    region = winevybe_payload.get("region") or winevybe_payload.get("appellation") or "Not disclosed"

    return {
        "wine_name": winevybe_payload.get("wine_name") or winevybe_payload.get("name"),
        "requested_vintage": winevybe_payload.get("vintage"),
        "summary": winevybe_payload.get("summary") or winevybe_payload.get("description") or "WineVybe returned no summary.",
        "description_breakdown": {
            "producer_and_region": f"{producer}, {region}",
            "grape_composition_and_style": grape_text,
            "tasting_profile": {
                "aroma": tasting.get("aroma") or tasting.get("nose") or [],
                "palate": tasting.get("palate") or [],
                "finish": tasting.get("finish") or "Not specified",
            },
            "drinking_experience": {
                "body": experience.get("body") or winevybe_payload.get("body") or "Not specified",
                "acidity": experience.get("acidity") or winevybe_payload.get("acidity") or "Not specified",
                "tannin": experience.get("tannin") or winevybe_payload.get("tannin") or "Not specified",
                "alcohol_impression": experience.get("alcohol_impression") or "Not specified",
                "serving_guidance": experience.get("serving_guidance") or winevybe_payload.get("serving") or "Not specified",
                "food_pairings": experience.get("food_pairings") or winevybe_payload.get("food_pairings") or [],
                "cellaring_window": experience.get("cellaring_window") or winevybe_payload.get("cellaring") or "Not specified",
            },
        },
        "vintage_intelligence": winevybe_payload.get("vintage_intelligence") or {},
        "climate_context": climate_context,
        "uncertainty_notes": winevybe_payload.get("uncertainty_notes") or [],
        "wine_type": winevybe_payload.get("wine_type"),
        "abv": winevybe_payload.get("abv"),
        "availability_status": winevybe_payload.get("availability") or winevybe_payload.get("availability_status"),
        "comparable_wines": winevybe_payload.get("comparable_wines"),
        "wine_id": winevybe_payload.get("wine_id"),
        "producer_id": winevybe_payload.get("producer_id"),
    }


def _build_source_highlights(
    winevybe_payload: Optional[dict[str, Any]],
    vinou_payload: Optional[dict[str, Any]],
    cms_payload: Optional[dict[str, Any]],
    source: str,
    structured: dict[str, Any],
) -> dict[str, Any]:
    return {
        "git_cms": {
            "available": bool(cms_payload),
            "producer": (cms_payload or {}).get("producer"),
            "region": (cms_payload or {}).get("region"),
            "wine_type": (cms_payload or {}).get("wine_type"),
        },
        "winevybe": {
            "available": bool(winevybe_payload),
            "producer": (winevybe_payload or {}).get("producer") or (winevybe_payload or {}).get("winery"),
            "region": (winevybe_payload or {}).get("region") or (winevybe_payload or {}).get("appellation"),
            "wine_type": (winevybe_payload or {}).get("wine_type"),
        },
        "vinou": {
            "available": bool(vinou_payload),
            "producer": (vinou_payload or {}).get("producer"),
            "region": (vinou_payload or {}).get("region"),
            "wine_type": (vinou_payload or {}).get("wine_type"),
        },
        "openai": {
            "available": source == "openai",
            "model": "gpt-4.1-mini" if source == "openai" else None,
            "summary_excerpt": structured.get("summary") if source == "openai" else None,
        },
    }


def _normalize_vinou_payload(vinou_payload: Optional[dict[str, Any]]) -> dict[str, Any]:
    if not vinou_payload:
        return {}

    tasting = vinou_payload.get("tasting_profile") or {}
    drinking = vinou_payload.get("drinking_experience") or {}
    grapes = vinou_payload.get("grape_composition") or vinou_payload.get("grapes")
    if isinstance(grapes, list):
        grape_text = ", ".join(str(item) for item in grapes)
    else:
        grape_text = str(grapes or vinou_payload.get("style") or "Not disclosed")

    producer = vinou_payload.get("producer") or "Not disclosed"
    region = vinou_payload.get("region") or "Not disclosed"

    return {
        "wine_name": vinou_payload.get("wine_name") or vinou_payload.get("name"),
        "requested_vintage": vinou_payload.get("vintage"),
        "summary": vinou_payload.get("summary") or vinou_payload.get("description") or "Vinou returned no summary.",
        "description_breakdown": {
            "producer_and_region": f"{producer}, {region}",
            "grape_composition_and_style": grape_text,
            "tasting_profile": {
                "aroma": tasting.get("aroma") or vinou_payload.get("aroma_notes") or [],
                "palate": tasting.get("palate") or vinou_payload.get("palate_notes") or [],
                "finish": tasting.get("finish") or vinou_payload.get("finish") or "Not specified",
            },
            "drinking_experience": {
                "body": drinking.get("body") or vinou_payload.get("body") or "Not specified",
                "acidity": drinking.get("acidity") or vinou_payload.get("acidity") or "Not specified",
                "tannin": drinking.get("tannin") or vinou_payload.get("tannin") or "Not specified",
                "alcohol_impression": drinking.get("alcohol_impression") or "Not specified",
                "serving_guidance": drinking.get("serving_guidance") or vinou_payload.get("serving") or "Not specified",
                "food_pairings": drinking.get("food_pairings") or vinou_payload.get("food_pairings") or [],
                "cellaring_window": drinking.get("cellaring_window") or vinou_payload.get("cellaring") or "Not specified",
            },
        },
        "vintage_intelligence": vinou_payload.get("vintage_intelligence") or {},
        "climate_context": vinou_payload.get("climate_context") or {},
        "uncertainty_notes": vinou_payload.get("uncertainty_notes") or [],
        "wine_type": vinou_payload.get("wine_type"),
        "abv": vinou_payload.get("abv"),
        "availability_status": vinou_payload.get("availability_status"),
        "comparable_wines": vinou_payload.get("comparable_wines"),
    }


def _normalize_wine_query(name: str, vintage: Optional[int]) -> tuple[str, Optional[int]]:
    normalized_name = name.strip()
    if not normalized_name:
        raise HTTPException(status_code=422, detail="Wine name cannot be empty.")

    if vintage is not None:
        return normalized_name, vintage

    match = re.search(r"(?:\bvintage\s+)?(19\d{2}|20\d{2}|2100)\b", normalized_name, flags=re.IGNORECASE)
    if not match:
        return normalized_name, None

    parsed_vintage = int(match.group(1))
    cleaned_name = re.sub(
        r"\s*(?:\bvintage\s+)?(?:19\d{2}|20\d{2}|2100)\b\s*",
        " ",
        normalized_name,
        flags=re.IGNORECASE,
    )
    cleaned_name = re.sub(r"\s{2,}", " ", cleaned_name).strip(" ,.-")
    return cleaned_name or normalized_name, parsed_vintage


def _build_growing_season_weather(
    climate_context: dict[str, Any],
    selected_vintage: Optional[int],
) -> dict[str, Any]:
    latitude = _parse_float(climate_context.get("latitude"))
    longitude = _parse_float(climate_context.get("longitude"))
    if latitude is None or longitude is None:
        return {"error": "No usable location returned for growing season weather analysis."}

    season = climate_context.get("growing_season") or {}
    start_month = _safe_int(season.get("start_month"), 4)
    start_day = _safe_int(season.get("start_day"), 1)
    end_month = _safe_int(season.get("end_month"), 10)
    end_day = _safe_int(season.get("end_day"), 31)

    if (end_month, end_day) < (start_month, start_day):
        start_month, start_day, end_month, end_day = 4, 1, 10, 31

    current_year = datetime.now(timezone.utc).year
    end_year = current_year - 1
    start_year = min((selected_vintage or end_year), end_year) - 20
    start_year = max(start_year, 1980)
    if start_year > end_year:
        start_year = end_year

    daily = _fetch_open_meteo_history(
        latitude=latitude,
        longitude=longitude,
        start_date=f"{start_year:04d}-{start_month:02d}-{start_day:02d}",
        end_date=f"{end_year:04d}-{end_month:02d}-{end_day:02d}",
    )
    by_year = _aggregate_seasonal_metrics(
        daily=daily,
        start_month=start_month,
        start_day=start_day,
        end_month=end_month,
        end_day=end_day,
    )
    if not by_year:
        return {"error": "No weather records were available for the requested growing season."}

    years_sorted = sorted(by_year)
    all_years = [by_year[year] for year in years_sorted]
    average_year = _summarize_average_year(all_years)

    selected = by_year.get(selected_vintage) if selected_vintage else None
    comparisons = _build_comparisons(selected, average_year)

    return {
        "region": climate_context.get("region") or "Unknown region",
        "location": {"latitude": latitude, "longitude": longitude},
        "growing_season": {
            "start_month": start_month,
            "start_day": start_day,
            "end_month": end_month,
            "end_day": end_day,
        },
        "all_years_period": {"start_year": years_sorted[0], "end_year": years_sorted[-1]},
        "all_years_average": average_year,
        "selected_vintage": selected,
        "selected_vs_average_comparison": comparisons,
        "yearly_metrics": [{"year": year, **by_year[year]} for year in years_sorted],
    }


def _parse_float(value: Any) -> Optional[float]:
    try:
        if value is None:
            return None
        return float(value)
    except (TypeError, ValueError):
        return None


def _safe_int(value: Any, fallback: int) -> int:
    try:
        parsed = int(value)
    except (TypeError, ValueError):
        return fallback
    return parsed


def _fetch_open_meteo_history(
    latitude: float,
    longitude: float,
    start_date: str,
    end_date: str,
) -> dict[str, list[Any]]:
    params = {
        "latitude": f"{latitude:.4f}",
        "longitude": f"{longitude:.4f}",
        "start_date": start_date,
        "end_date": end_date,
        "daily": "temperature_2m_max,temperature_2m_min,precipitation_sum",
        "timezone": "UTC",
    }
    url = f"https://archive-api.open-meteo.com/v1/archive?{parse.urlencode(params)}"

    try:
        with request.urlopen(url, timeout=20) as response:
            payload = json.loads(response.read().decode("utf-8"))
    except Exception as exc:
        raise HTTPException(status_code=502, detail=f"Open-Meteo call failed: {exc}") from exc

    daily = payload.get("daily")
    if not isinstance(daily, dict):
        raise HTTPException(status_code=502, detail="Open-Meteo response did not include daily weather data.")
    return daily


def _aggregate_seasonal_metrics(
    daily: dict[str, list[Any]],
    start_month: int,
    start_day: int,
    end_month: int,
    end_day: int,
) -> dict[int, dict[str, float]]:
    dates = daily.get("time") or []
    highs = daily.get("temperature_2m_max") or []
    lows = daily.get("temperature_2m_min") or []
    rain = daily.get("precipitation_sum") or []

    length = min(len(dates), len(highs), len(lows), len(rain))
    season_by_year: dict[int, dict[str, list[float]]] = {}

    for idx in range(length):
        raw_date = dates[idx]
        try:
            stamp = datetime.strptime(raw_date, "%Y-%m-%d")
        except (TypeError, ValueError):
            continue

        month_day = (stamp.month, stamp.day)
        if month_day < (start_month, start_day) or month_day > (end_month, end_day):
            continue

        year_bucket = season_by_year.setdefault(
            stamp.year,
            {
                "highs": [],
                "lows": [],
                "rain": [],
            },
        )

        high = _parse_float(highs[idx])
        low = _parse_float(lows[idx])
        precipitation = _parse_float(rain[idx])
        if high is not None:
            year_bucket["highs"].append(high)
        if low is not None:
            year_bucket["lows"].append(low)
        if precipitation is not None:
            year_bucket["rain"].append(precipitation)

    summarized: dict[int, dict[str, float]] = {}
    for year, values in season_by_year.items():
        if not values["highs"] or not values["lows"]:
            continue
        rainy_days = sum(1 for entry in values["rain"] if entry >= 1.0)
        summarized[year] = {
            "avg_high_c": round(sum(values["highs"]) / len(values["highs"]), 2),
            "max_high_c": round(max(values["highs"]), 2),
            "avg_low_c": round(sum(values["lows"]) / len(values["lows"]), 2),
            "min_low_c": round(min(values["lows"]), 2),
            "rain_total_mm": round(sum(values["rain"]), 2),
            "rainy_days": rainy_days,
        }
    return summarized


def _summarize_average_year(all_years: list[dict[str, float]]) -> dict[str, float]:
    count = len(all_years)
    return {
        "avg_high_c": round(sum(item["avg_high_c"] for item in all_years) / count, 2),
        "max_high_c": round(sum(item["max_high_c"] for item in all_years) / count, 2),
        "avg_low_c": round(sum(item["avg_low_c"] for item in all_years) / count, 2),
        "min_low_c": round(sum(item["min_low_c"] for item in all_years) / count, 2),
        "rain_total_mm": round(sum(item["rain_total_mm"] for item in all_years) / count, 2),
        "rainy_days": round(sum(item["rainy_days"] for item in all_years) / count, 2),
    }


def _build_comparisons(
    selected_vintage: Optional[dict[str, float]],
    average_year: dict[str, float],
) -> dict[str, Optional[float]]:
    if not selected_vintage:
        return {
            "avg_high_delta_c": None,
            "max_high_vs_avg_high_delta_c": None,
            "avg_low_delta_c": None,
            "min_low_vs_avg_low_delta_c": None,
            "rain_total_delta_mm": None,
            "rainy_days_delta": None,
        }

    return {
        "avg_high_delta_c": round(selected_vintage["avg_high_c"] - average_year["avg_high_c"], 2),
        "max_high_vs_avg_high_delta_c": round(
            selected_vintage["max_high_c"] - average_year["avg_high_c"],
            2,
        ),
        "avg_low_delta_c": round(selected_vintage["avg_low_c"] - average_year["avg_low_c"], 2),
        "min_low_vs_avg_low_delta_c": round(selected_vintage["min_low_c"] - average_year["avg_low_c"], 2),
        "rain_total_delta_mm": round(selected_vintage["rain_total_mm"] - average_year["rain_total_mm"], 2),
        "rainy_days_delta": round(selected_vintage["rainy_days"] - average_year["rainy_days"], 2),
    }
